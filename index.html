<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BookReader - ·ª®ng d·ª•ng ƒë·ªçc s√°ch di ƒë·ªông</title>
    <style>
        /* CSS Reset v√† Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary-color: #4f46e5;
            --primary-dark: #4338ca;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --border-color: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --radius: 8px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --border-color: #374151;
        }

        /* Sepia Theme */
        [data-theme="sepia"] {
            --primary-color: #d97706;
            --primary-dark: #b45309;
            --text-primary: #44403c;
            --text-secondary: #78716c;
            --bg-primary: #fef7ed;
            --bg-secondary: #fffbeb;
            --border-color: #f59e0b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
            touch-action: pan-y;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Compact Header */
        .reader-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            height: 50px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .menu-toggle-btn,
        .settings-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: var(--text-primary);
            cursor: pointer;
            padding: 6px;
            border-radius: var(--radius);
            transition: var(--transition);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle-btn:hover,
        .settings-btn:hover {
            background: var(--bg-secondary);
        }

        .book-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .page-indicator {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: var(--radius);
            min-width: 50px;
            text-align: center;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            top: 0;
            left: -100%;
            width: 320px;
            height: 100vh;
            background: var(--bg-secondary);
            z-index: 1000;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }

        .sidebar.active {
            left: 0;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            height: 50px;
        }

        .sidebar-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-settings-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: var(--radius);
            transition: var(--transition);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-settings-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .close-menu-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius);
            transition: var(--transition);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-menu-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        /* TOC Search Styles */
        .toc-search-container {
            position: relative;
            margin-bottom: 16px;
        }

        .toc-search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .toc-search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .toc-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
        }

        .toc-search-result {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 0.8rem;
            transition: var(--transition);
        }

        .toc-search-result:hover {
            background: var(--bg-secondary);
        }

        .toc-search-result:last-child {
            border-bottom: none;
        }

        .toc-search-text {
            color: var(--text-primary);
            line-height: 1.4;
        }

        .toc-no-results {
            padding: 15px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            font-size: 0.8rem;
        }

        .search-highlight {
            background: #ffeb3b;
            color: #000;
            padding: 1px 2px;
            border-radius: 2px;
        }

        [data-theme="dark"] .search-highlight {
            background: #f59e0b;
            color: #000;
        }

        [data-theme="sepia"] .search-highlight {
            background: #d97706;
            color: #fff;
        }

        /* TOC Styles */
        .toc-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toc-container {
            flex: 1;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-primary);
            overflow-y: auto;
        }

        #toc-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .toc-item {
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
            display: flex;
        }

        .toc-item:last-child {
            border-bottom: none;
        }

        .toc-item:hover {
            background: var(--bg-secondary);
        }

        .toc-link {
            display: flex;
            padding: 10px 12px;
            color: var(--text-primary);
            text-decoration: none;
            font-size: 0.8rem;
            transition: var(--transition);
            border-left: 3px solid transparent;
            line-height: 1.4;
            min-height: 44px;
            align-items: center;
            flex: 1;
        }

        .toc-link:hover {
            background: var(--bg-secondary);
            border-left-color: var(--primary-color);
        }

        .toc-link.level-1 {
            font-weight: 600;
            padding-left: 12px;
        }

        .toc-link.level-2 {
            padding-left: 20px;
            font-size: 0.78rem;
            font-weight: 500;
        }

        .toc-link.level-3 {
            padding-left: 28px;
            font-size: 0.76rem;
            color: var(--text-secondary);
        }

        .toc-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .toc-placeholder {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            font-size: 0.8rem;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            z-index: 1000;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border-color);
        }

        .settings-panel.active {
            right: 0;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            height: 50px;
        }

        .settings-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-settings-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius);
            transition: var(--transition);
        }

        .close-settings-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .setting-item label {
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .setting-item select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            min-width: 120px;
        }

        .upload-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .upload-section h4 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            width: 100%;
            padding: 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .upload-btn:hover {
            background: var(--primary-dark);
        }

        /* Main Content */
        .main-wrapper {
            position: relative;
            width: 100%;
            height: 100vh;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }

        .content-reader {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            position: relative;
        }

        /* File Content */
        .file-content {
            max-width: 100%;
            margin: 0 auto;
            font-size: 1rem;
            line-height: 1.7;
            color: var(--text-primary);
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .file-content * {
            max-width: 100%;
        }

        .file-content h1, 
        .file-content h2, 
        .file-content h3 {
            margin: 1.2em 0 0.6em 0;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .file-content h1 {
            font-size: 1.4em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.3em;
        }

        .file-content h2 {
            font-size: 1.2em;
            border-left: 4px solid var(--primary-color);
            padding-left: 12px;
        }

        .file-content h3 {
            font-size: 1.1em;
        }

        .file-content p {
            margin-bottom: 1em;
            text-align: justify;
        }

        .file-content table {
            width: 100% !important;
            border-collapse: collapse;
            margin: 1em 0;
            font-size: 0.9em;
            display: block;
            overflow-x: auto;
        }

        .file-content table, 
        .file-content th, 
        .file-content td {
            border: 1px solid var(--border-color);
        }

        .file-content th, 
        .file-content td {
            padding: 8px;
            text-align: left;
        }

        .file-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .file-content img {
            max-width: 100% !important;
            height: auto !important;
            border-radius: var(--radius);
            margin: 1em 0;
        }

        /* Progress Bar */
        .reader-footer {
            background: var(--bg-primary);
            border-top: 1px solid var(--border-color);
            padding: 8px 16px;
        }

        .progress-bar {
            width: 100%;
            height: 3px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Placeholder Content */
        .placeholder-content {
            text-align: center;
            padding: 40px 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .welcome-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .placeholder-content h2 {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .placeholder-content p {
            color: var(--text-secondary);
            margin-bottom: 25px;
        }

        .welcome-features {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .feature {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .feature-icon {
            font-size: 1.1rem;
        }

        .get-started-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .get-started-btn:hover {
            background: var(--primary-dark);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 2000;
            color: white;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Documents List */
        .documents-section {
            margin-bottom: 20px;
        }

        .documents-section h3 {
            font-size: 0.95rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .documents-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-primary);
        }

        .document-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: var(--transition);
        }

        .document-item:hover {
            background: var(--bg-secondary);
        }

        .document-item:last-child {
            border-bottom: none;
        }

        .document-icon {
            font-size: 1.2rem;
            margin-right: 12px;
        }

        .document-info {
            flex: 1;
        }

        .document-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .document-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .badge-new {
            background: var(--primary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .document-placeholder {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            font-size: 0.8rem;
        }

        /* Admin Section Styles */
        .admin-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .admin-section h4 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .admin-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .admin-btn {
            flex: 1;
            padding: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 0.85rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .admin-btn.logout {
            background: #dc2626;
        }

        .admin-btn:hover {
            opacity: 0.9;
        }

        .upload-section {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .upload-section h5 {
            font-size: 0.9rem;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .stats-section {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .document-stats {
            margin-top: 15px;
        }

        .document-stats h4 {
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .doc-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem;
        }

        .doc-stat-item:last-child {
            border-bottom: none;
        }

        .doc-name {
            color: var(--text-primary);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .doc-views {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        /* Form Groups */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* GitHub Buttons */
        .github-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .github-btn {
            padding: 12px;
            border: none;
            border-radius: var(--radius);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .github-btn.primary {
            background: var(--primary-color);
            color: white;
        }

        .github-btn.secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .github-btn:hover {
            opacity: 0.9;
        }

        /* File Content in iframe */
        .file-content iframe {
            background: var(--bg-primary);
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
            }
            
            .settings-panel {
                width: 100%;
            }
            
            .reader-header {
                padding: 8px 12px;
            }
            
            .book-title {
                font-size: 0.9rem;
            }
            
            .page-indicator {
                font-size: 0.8rem;
                min-width: 45px;
            }
            
            .sidebar-header {
                padding: 16px;
            }
            
            .content-reader {
                padding: 12px;
            }
            
            .file-content {
                font-size: 0.95rem;
            }
            
            .admin-buttons {
                flex-direction: column;
            }
            
            .github-buttons {
                flex-direction: column;
            }
            
            .stat-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
        }

        /* Touch Improvements */
        @media (hover: none) {
            .menu-toggle-btn:hover,
            .settings-btn:hover,
            .sidebar-settings-btn:hover,
            .toc-link:hover {
                background: transparent;
            }
            
            .menu-toggle-btn:active,
            .settings-btn:active,
            .sidebar-settings-btn:active,
            .toc-link:active {
                background: var(--bg-secondary);
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar Menu -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>üìñ BookReader</h2>
            <div class="sidebar-controls">
                <button class="sidebar-settings-btn" id="sidebar-settings-btn" title="C√†i ƒë·∫∑t">
                    <span class="settings-icon">‚öôÔ∏è</span>
                </button>
                <button class="close-menu-btn" id="close-menu-btn">‚úï</button>
            </div>
        </div>
        
        <div class="sidebar-content">
            <!-- Danh s√°ch t√†i li·ªáu -->
            <div class="documents-section">
                <h3>üìö T√†i li·ªáu c√≥ s·∫µn</h3>
                <div class="documents-list" id="documents-list">
                    <div class="document-placeholder">ƒêang t·∫£i danh s√°ch...</div>
                </div>
            </div>

            <!-- T√¨m ki·∫øm m·ª•c l·ª•c -->
            <div class="toc-search-container">
                <input type="text" id="toc-search" placeholder="üîç T√¨m ki·∫øm m·ª•c l·ª•c..." class="toc-search-input">
                <div class="toc-search-results" id="toc-search-results"></div>
            </div>

            <!-- M·ª•c l·ª•c -->
            <div class="toc-section">
                <div class="toc-container">
                    <ul id="toc-list">
                        <li class="toc-placeholder">Ch·ªçn t√†i li·ªáu ƒë·ªÉ xem m·ª•c l·ª•c</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-wrapper" id="main-wrapper">
        <!-- Compact Header -->
        <header class="reader-header">
            <div class="header-left">
                <button class="menu-toggle-btn" id="menu-toggle-btn" title="Menu">
                    <span class="menu-icon">‚ò∞</span>
                </button>
                <span class="book-title" id="book-title">BookReader</span>
            </div>
            
            <div class="header-right">
                <div class="page-indicator" id="page-indicator">
                    <span id="current-page">-</span>/<span id="total-pages">-</span>
                </div>
                <button class="settings-btn" id="settings-btn" title="C√†i ƒë·∫∑t">
                    <span class="settings-icon">‚öôÔ∏è</span>
                </button>
            </div>
        </header>

        <!-- Reader Content -->
        <main class="content-reader" id="content-reader">
            <div class="placeholder-content" id="placeholder-content">
                <div class="welcome-icon">üìö</div>
                <h2>Ch√†o m·ª´ng ƒë·∫øn v·ªõi BookReader</h2>
                <p>·ª®ng d·ª•ng ƒë·ªçc s√°ch di ƒë·ªông chuy√™n nghi·ªáp</p>
                <div class="welcome-features">
                    <div class="feature">
                        <span class="feature-icon">üì±</span>
                        <span>T·ªëi ∆∞u cho ƒëi·ªán tho·∫°i</span>
                    </div>
                    <div class="feature">
                        <span class="feature-icon">üëÜ</span>
                        <span>Vu·ªët ƒë·ªÉ chuy·ªÉn trang</span>
                    </div>
                    <div class="feature">
                        <span class="feature-icon">üé®</span>
                        <span>Ch·ªß ƒë·ªÅ ƒë·ªçc t√πy ch·ªânh</span>
                    </div>
                    <div class="feature">
                        <span class="feature-icon">üåê</span>
                        <span>T·∫£i t·ª´ GitHub</span>
                    </div>
                </div>
                <button class="get-started-btn" id="get-started-btn">
                    B·∫Øt ƒë·∫ßu ƒë·ªçc ngay
                </button>
            </div>
            
            <div id="file-content-display" class="file-content" style="display:none;"></div>
        </main>

        <!-- Progress Bar -->
        <footer class="reader-footer">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </footer>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <h3>C√†i ƒë·∫∑t ƒë·ªçc</h3>
            <button class="close-settings-btn" id="close-settings-btn">‚úï</button>
        </div>
        <div class="settings-content">
            <div class="setting-item">
                <label for="font-size">C·ª° ch·ªØ:</label>
                <select id="font-size">
                    <option value="0.9">Nh·ªè</option>
                    <option value="1" selected>V·ª´a</option>
                    <option value="1.1">L·ªõn</option>
                    <option value="1.2">R·∫•t l·ªõn</option>
                </select>
            </div>
            <div class="setting-item">
                <label for="theme">Ch·ªß ƒë·ªÅ:</label>
                <select id="theme">
                    <option value="light" selected>S√°ng</option>
                    <option value="sepia">Sepia</option>
                    <option value="dark">T·ªëi</option>
                </select>
            </div>
            
            <!-- GitHub Configuration Section -->
                <div class="github-section">
                <h4>üìÇ C·∫•u h√¨nh GitHub</h4>
                <div id="gh-config-section">
                    <div class="form-group">
                        <label for="gh-owner">GitHub Owner:</label>
                        <input type="text" id="gh-owner" placeholder="username" value="Datkep92">
                    </div>
                    <div class="form-group">
                        <label for="gh-repo">GitHub Repo:</label>
                        <input type="text" id="gh-repo" placeholder="repository-name" value="aquyet">
                    </div>
                    <div class="form-group">
                        <label for="gh-base-path">Base Path:</label>
                        <input type="text" id="gh-base-path" placeholder="folder-name" value="docs/Quyet">
                    </div>
                    <div class="form-group">
                        <label for="gh-token">Token (t√πy ch·ªçn):</label>
                        <input type="password" id="gh-token" placeholder="ghp_xxx">
                    </div>
                </div>
                        <div class="github-buttons">
                    <button type="button" class="github-btn" id="save-config-btn">
                        üíæ L∆∞u c·∫•u h√¨nh
                    </button>
                    <button type="button" class="github-btn primary" id="load-from-github-btn">
                        üåê T·∫£i t·ª´ GitHub
                    </button>
                    <button type="button" class="github-btn secondary" id="reconfigure-github-btn" style="display:none;">
                        ‚öôÔ∏è C·∫•u h√¨nh l·∫°i GitHub
                    </button>
                    <!-- Auto-load note -->
                    <p id="gh-autoload-note" style="font-size:0.9rem;color:#1f2937;margin-top:10px;">üîÅ T·ª± ƒë·ªông t·∫£i/qu√©t GitHub (F5 ƒë·ªÉ qu√©t).</p>
                </div>
            </div>

            <!-- Admin Section -->
            <div class="admin-section" id="admin-section" style="display:none;">
                <h4>üë®‚Äçüíº Qu·∫£n tr·ªã</h4>
                <div class="admin-buttons">
                    <button type="button" class="admin-btn" id="admin-login-btn">
                        üîë ƒêƒÉng nh·∫≠p Admin
                    </button>
                    <button type="button" class="admin-btn logout" id="admin-logout-btn">
                        üö™ ƒêƒÉng xu·∫•t
                    </button>
                </div>

                <!-- Upload Section -->
                <div class="upload-section" id="upload-section">
                    <h5>üì§ Upload t√†i li·ªáu m·ªõi</h5>
                    <div class="form-group">
                        <label for="author-name">T√°c gi·∫£:</label>
                        <input type="text" id="author-name" placeholder="T√™n t√°c gi·∫£">
                    </div>
                    <div class="form-group">
                        <label for="book-title-input">Ti√™u ƒë·ªÅ:</label>
                        <input type="text" id="book-title-input" placeholder="Ti√™u ƒë·ªÅ s√°ch">
                    </div>
                    <div class="form-group">
                        <label for="file-input">File HTML:</label>
                        <input type="file" id="file-input" accept=".html,.htm">
                    </div>
                    <div id="upload-preview" style="margin-top:8px;padding:8px;border-radius:6px;background:var(--bg-primary);border:1px solid var(--border-color);display:none;font-size:0.9rem;color:var(--text-secondary)"></div>
                    <button type="button" class="upload-btn" id="upload-btn">
                        üì§ Upload l√™n GitHub
                    </button>
                </div>

                <!-- Statistics -->
                <div class="stats-section">
                    <h5>üìä Th·ªëng k√™ truy c·∫≠p</h5>
                    <div class="admin-stats" id="admin-stats">
                        <!-- Stats will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <p>ƒêang t·∫£i s√°ch...</p>
    </div>

    <script>
        // scriptt.js - Integrated JavaScript
        class BookReader {
            constructor() {
                this.initializeElements();
                this.bindEvents();
                this.currentPage = 0;
                this.totalPages = 0;
                this.headings = [];
                this.isMenuOpen = false;
                this.isSettingsOpen = false;
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.currentBook = null;
                this.documents = [];
                this.adminLogged = localStorage.getItem('adminLogged') === 'true';
                this.deviceId = this.getDeviceId();
                
                this.ghConfig = {
                    owner: 'Datkep92',
                    repo: 'aquyet',
                    basePath: 'docs/Quyet',
                    token: ''
                };
                
                console.log('üìñ BookReader initialized');
                this.loadConfig();
                this.loadLastBook();
                this.disableZoom();
                this.disableHorizontalScroll();
                this.loadPreferences();
                this.initializeAdmin();
                this.logAccess('app_start');

                // Auto-load documents from configured GitHub repo on app start
                if (this.ghConfig && this.ghConfig.owner && this.ghConfig.repo) {
                    // Fire-and-forget; loadFromGitHub does its own error handling
                    this.loadFromGitHub().catch(() => {});
                }
            }

            initializeElements() {
                // Sidebar elements
                this.sidebar = document.getElementById('sidebar');
                this.menuToggleBtn = document.getElementById('menu-toggle-btn');
                this.closeMenuBtn = document.getElementById('close-menu-btn');
                this.sidebarSettingsBtn = document.getElementById('sidebar-settings-btn');
                
                // Settings elements
                this.settingsPanel = document.getElementById('settings-panel');
                this.settingsBtn = document.getElementById('settings-btn');
                this.closeSettingsBtn = document.getElementById('close-settings-btn');
                
                // GitHub elements
                this.ghConfigSection = document.getElementById('gh-config-section');
                this.ghOwner = document.getElementById('gh-owner');
                this.ghRepo = document.getElementById('gh-repo');
                this.ghBasePath = document.getElementById('gh-base-path');
                this.ghToken = document.getElementById('gh-token');
                this.saveConfigBtn = document.getElementById('save-config-btn');
                this.loadFromGitHubBtn = document.getElementById('load-from-github-btn');
                this.reconfigureGitHubBtn = document.getElementById('reconfigure-github-btn');
                
                // Admin elements
                this.adminPanel = document.getElementById('admin-panel');
                this.adminLoginBtn = document.getElementById('admin-login-btn');
                this.adminLogoutBtn = document.getElementById('admin-logout-btn');
                this.adminSection = document.getElementById('admin-section');
                this.adminStats = document.getElementById('admin-stats');
                this.uploadSection = document.getElementById('upload-section');
                
                // File upload elements
                this.fileInput = document.getElementById('file-input');
                this.authorName = document.getElementById('author-name');
                this.bookTitleInput = document.getElementById('book-title-input');
                this.uploadBtn = document.getElementById('upload-btn');
                // disable until a file is processed
                if (this.uploadBtn) this.uploadBtn.disabled = true;
                
                // Documents list
                this.documentsList = document.getElementById('documents-list');
                
                // Content elements
                this.mainWrapper = document.getElementById('main-wrapper');
                this.contentReader = document.getElementById('content-reader');
                this.fileContentDiv = document.getElementById('file-content-display');
                this.placeholderDiv = document.getElementById('placeholder-content');
                this.bookTitle = document.getElementById('book-title');
                
                // Table of contents
                this.tocList = document.getElementById('toc-list');
                this.tocSearch = document.getElementById('toc-search');
                this.tocSearchResults = document.getElementById('toc-search-results');
                
                // Page indicator
                this.currentPageEl = document.getElementById('current-page');
                this.totalPagesEl = document.getElementById('total-pages');
                this.pageIndicator = document.getElementById('page-indicator');
                
                // Progress
                this.progressFill = document.getElementById('progress-fill');
                
                // Settings
                this.fontSizeSelect = document.getElementById('font-size');
                this.themeSelect = document.getElementById('theme');
                
                // Loading
                this.loadingOverlay = document.getElementById('loading-overlay');

                // Pending upload buffer for processed files
                this.pendingUpload = null;
                
                // Get started button
                this.getStartedBtn = document.getElementById('get-started-btn');
            }

            bindEvents() {
                // Menu controls
                this.menuToggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleMenu();
                });
                
                this.closeMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeMenu();
                });
                
                // Settings controls
                this.settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleSettings();
                });
                
                this.sidebarSettingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleSettings();
                });
                
                this.closeSettingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeSettings();
                });
                
                // GitHub operations
                this.saveConfigBtn.addEventListener('click', () => {
                    this.saveGitHubConfig();
                });
                
                this.loadFromGitHubBtn.addEventListener('click', () => {
                    this.loadFromGitHub();
                });
                
                this.reconfigureGitHubBtn.addEventListener('click', () => {
                    this.toggleGitHubConfig();
                });
                
                // Get started button
                this.getStartedBtn.addEventListener('click', () => {
                    this.toggleSettings();
                });
                
                // Settings changes
                this.fontSizeSelect.addEventListener('change', (e) => {
                    this.changeFontSize(e.target.value);
                });
                
                this.themeSelect.addEventListener('change', (e) => {
                    this.changeTheme(e.target.value);
                });
                
                // Admin operations
                this.adminLoginBtn.addEventListener('click', () => {
                    this.showAdminLogin();
                });
                
                this.adminLogoutBtn.addEventListener('click', () => {
                    this.adminLogout();
                });
                
                this.uploadBtn.addEventListener('click', () => {
                    this.uploadFileToGitHub();
                });

                // Pre-process file on select so we show a preview and enable upload
                this.fileInput.addEventListener('change', async () => {
                    const f = this.fileInput.files[0];
                    if (!f) return;
                    try {
                        this.showMessage('üîç ƒêang x·ª≠ l√Ω file...');
                        const res = await this.handleFileSelect(f, { fileContentDiv: this.fileContentDiv, bookTitleEl: null, contentReaderEl: this.contentReader });
                        // Keep pending processed result until upload
                        this.pendingUpload = { file: f, book: res.book, processedContent: res.processedContent };

                        // Fill title if missing
                        if (!this.bookTitleInput.value) this.bookTitleInput.value = res.book.name;

                        // Enable upload
                        this.uploadBtn.disabled = false;

                        // Show preview summary
                        this.showUploadPreview(res);
                        this.showMessage('‚úÖ File ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω, s·∫µn s√†ng upload');
                    } catch (e) {
                        console.error('Preprocess error', e);
                        this.showMessage('‚ùå L·ªói x·ª≠ l√Ω file: ' + (e.message || e));
                    }
                });
                
                // Touch events for swipe navigation
                this.contentReader.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.contentReader.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
                
                // Close panels when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.isMenuOpen && !e.target.closest('.sidebar') && !e.target.closest('.menu-toggle-btn')) {
                        this.closeMenu();
                    }
                    if (this.isSettingsOpen && !e.target.closest('.settings-panel') && !e.target.closest('.settings-btn') && !e.target.closest('.sidebar-settings-btn')) {
                        this.closeSettings();
                    }
                });

                // Prevent event propagation
                this.sidebar.addEventListener('click', (e) => e.stopPropagation());
                this.settingsPanel.addEventListener('click', (e) => e.stopPropagation());

                // Scroll event for page tracking
                this.contentReader.addEventListener('scroll', () => {
                    this.updateCurrentPage();
                    this.saveReadingProgress();
                });
            }

            /* =========================
               ADMIN & AUTHENTICATION
               ========================= */
            initializeAdmin() {
                if (this.adminLogged) {
                    this.showAdminPanel();
                }
            }

            showAdminLogin() {
                const username = prompt('T√™n ƒëƒÉng nh·∫≠p:');
                const password = prompt('M·∫≠t kh·∫©u:');
                
                if (username === 'admin' && password === '123456') {
                    this.adminLogged = true;
                    localStorage.setItem('adminLogged', 'true');
                    this.showAdminPanel();
                    this.showMessage('‚úÖ ƒêƒÉng nh·∫≠p Admin th√†nh c√¥ng!');
                } else {
                    this.showMessage('‚ùå Sai t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u!');
                }
            }

            adminLogout() {
                this.adminLogged = false;
                localStorage.setItem('adminLogged', 'false');
                this.adminSection.style.display = 'none';
                this.showMessage('‚úÖ ƒê√£ ƒëƒÉng xu·∫•t!');
            }

            showAdminPanel() {
                this.adminSection.style.display = 'block';
                this.loadAccessStats();
            }

            getDeviceId() {
                let deviceId = localStorage.getItem('bookreader_device_id');
                if (!deviceId) {
                    deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('bookreader_device_id', deviceId);
                }
                return deviceId;
            }

            async logAccess(action, documentTitle = '') {
                const logEntry = {
                    deviceId: this.deviceId,
                    action: action,
                    document: documentTitle,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                
                // Save to localStorage for immediate access
                const accessLogs = JSON.parse(localStorage.getItem('bookreader_access_logs') || '[]');
                accessLogs.push(logEntry);
                
                // Keep only last 1000 entries
                if (accessLogs.length > 1000) {
                    accessLogs.splice(0, accessLogs.length - 1000);
                }
                
                localStorage.setItem('bookreader_access_logs', JSON.stringify(accessLogs));
                
                // Upload to GitHub if admin is logged in and config is set
                if (this.adminLogged && this.ghConfig.owner && this.ghConfig.repo) {
                    await this.uploadAccessLogs();
                }
            }

            async uploadAccessLogs() {
                try {
                    const accessLogs = JSON.parse(localStorage.getItem('bookreader_access_logs') || '[]');
                    const stats = this.calculateStats(accessLogs);
                    
                    const statsData = {
                        totalDevices: this.getUniqueDevices(accessLogs).length,
                        totalAccess: accessLogs.length,
                        onlineDevices: this.getOnlineDevices(accessLogs),
                        documentStats: this.getDocumentStats(accessLogs),
                        lastUpdated: new Date().toISOString()
                    };
                    
                    // Upload stats to GitHub
                    const statsContent = JSON.stringify(statsData, null, 2);
                    await this.uploadToGitHub('stats/access_stats.json', statsContent);
                    
                } catch (error) {
                    console.error('Error uploading access logs:', error);
                }
            }

            calculateStats(accessLogs) {
                const uniqueDevices = this.getUniqueDevices(accessLogs);
                const onlineDevices = this.getOnlineDevices(accessLogs);
                const documentStats = this.getDocumentStats(accessLogs);
                
                return {
                    totalDevices: uniqueDevices.length,
                    totalAccess: accessLogs.length,
                    onlineDevices: onlineDevices,
                    documentStats: documentStats
                };
            }

            getUniqueDevices(accessLogs) {
                const deviceMap = new Map();
                accessLogs.forEach(log => {
                    deviceMap.set(log.deviceId, log);
                });
                return Array.from(deviceMap.values());
            }

            getOnlineDevices(accessLogs) {
                const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
                return accessLogs
                    .filter(log => log.timestamp > fiveMinutesAgo)
                    .map(log => log.deviceId)
                    .filter((value, index, self) => self.indexOf(value) === index);
            }

            getDocumentStats(accessLogs) {
                const docStats = {};
                accessLogs.forEach(log => {
                    if (log.document) {
                        if (!docStats[log.document]) {
                            docStats[log.document] = { views: 0, lastAccess: '' };
                        }
                        docStats[log.document].views++;
                        if (log.timestamp > docStats[log.document].lastAccess) {
                            docStats[log.document].lastAccess = log.timestamp;
                        }
                    }
                });
                return docStats;
            }

            loadAccessStats() {
                const accessLogs = JSON.parse(localStorage.getItem('bookreader_access_logs') || '[]');
                const stats = this.calculateStats(accessLogs);
                
                this.adminStats.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">T·ªïng thi·∫øt b·ªã:</span>
                        <span class="stat-value">${stats.totalDevices}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ƒêang online:</span>
                        <span class="stat-value">${stats.onlineDevices.length}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">T·ªïng truy c·∫≠p:</span>
                        <span class="stat-value">${stats.totalAccess}</span>
                    </div>
                    <div class="document-stats">
                        <h4>Th·ªëng k√™ theo t√†i li·ªáu:</h4>
                        ${Object.entries(stats.documentStats).map(([doc, data]) => `
                            <div class="doc-stat-item">
                                <span class="doc-name">${doc}</span>
                                <span class="doc-views">${data.views} l∆∞·ª£t xem</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            /* =========================
               GITHUB INTEGRATION
               ========================= */
            loadConfig() {
                const savedConfig = localStorage.getItem('bookreader_gh_config');
                if (savedConfig) {
                    this.ghConfig = JSON.parse(savedConfig);
                    this.ghOwner.value = this.ghConfig.owner;
                    this.ghRepo.value = this.ghConfig.repo;
                    this.ghBasePath.value = this.ghConfig.basePath;
                    this.ghToken.value = this.ghConfig.token;
                    
                    // Hide config inputs if already configured
                    this.toggleGitHubConfig(false);
                }
                
                // Load saved documents
                const savedDocuments = localStorage.getItem('bookreader_documents');
                if (savedDocuments) {
                    this.documents = JSON.parse(savedDocuments);
                    this.renderDocumentsList();
                }
            }

            saveGitHubConfig() {
                this.ghConfig = {
                    owner: this.ghOwner.value.trim(),
                    repo: this.ghRepo.value.trim(),
                    basePath: this.ghBasePath.value.trim(),
                    token: this.ghToken.value.trim()
                };
                
                localStorage.setItem('bookreader_gh_config', JSON.stringify(this.ghConfig));
                this.toggleGitHubConfig(false);
                this.showMessage('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh GitHub!');
            }

            toggleGitHubConfig(show = true) {
                const inputs = this.ghConfigSection.querySelectorAll('input');
                inputs.forEach(input => {
                    input.style.display = show ? 'block' : 'none';
                });
                
                this.saveConfigBtn.style.display = show ? 'block' : 'none';
                this.reconfigureGitHubBtn.style.display = show ? 'none' : 'block';
            }

            // Load documents.json OR scan the whole base folder recursively and update UI
            async loadFromGitHub() {
                if (!this.ghConfig.owner || !this.ghConfig.repo) {
                    this.showMessage('‚ùå Vui l√≤ng nh·∫≠p GitHub Owner v√† Repo!');
                    return;
                }
                
                try {
                    this.showLoading();
                    if (this.uploadBtn) this.uploadBtn.disabled = true;
                    
                    // Try to load documents.json first. If it exists, use it.
                    const docsUrl = `https://raw.githubusercontent.com/${this.ghConfig.owner}/${this.ghConfig.repo}/main/${this.ghConfig.basePath}/documents.json`;
                    const res = await fetch(docsUrl);
                    if (res.ok) {
                        const documents = await res.json();
                        if (Array.isArray(documents) && documents.length) {
                            this.documents = documents;
                        }
                    }

                    // Always scan the base path and merge any files not present in documents.json
                    const files = await this.fetchAllFilesFromGitHub(this.ghConfig.basePath);
                    const relFiles = files.map(p => p.replace(this.ghConfig.basePath + '/', ''));
                    const existing = Array.isArray(this.documents) ? this.documents.slice() : [];
                    // add missing files
                    relFiles.forEach((f, i) => {
                        if (!existing.find(d => d.file === f)) {
                            existing.push({ id: `id_${i}_${Date.now()}`, title: f.split('/').pop(), author: '', file: f, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), views: [] });
                        }
                    });
                    this.documents = existing;

                    // save and render
                    localStorage.setItem('bookreader_documents', JSON.stringify(this.documents));
                    this.renderDocumentsList();
                    this.hideLoading();
                    this.showMessage(`‚úÖ ƒê√£ t·∫£i ${this.documents.length} t√†i li·ªáu t·ª´ GitHub!`);
                    this.closeSettings();

                    if (this.documents.length) {
                        // try opening the first available document (skip missing/404)
                        for (let i = 0; i < this.documents.length; i++) {
                            const ok = await this.openDocument(i);
                            if (ok) break;
                        }
                    }
                    
                } catch (error) {
                    this.hideLoading();
                    console.error('‚ùå GitHub load error:', error);
                    this.showMessage('‚ùå L·ªói t·∫£i t·ª´ GitHub: ' + error.message);
                }
            }

            // compact recursive listing via GitHub contents API
            async fetchAllFilesFromGitHub(path = '') {
                const files = [];
                const apiBase = `https://api.github.com/repos/${this.ghConfig.owner}/${this.ghConfig.repo}/contents`;
                const headers = this.ghConfig.token ? { Authorization: `token ${this.ghConfig.token}` } : {};

                const walk = async (p) => {
                    const url = `${apiBase}/${p}`.replace(/\\/g, '/');
                    const r = await fetch(url, { headers });
                    if (!r.ok) return;
                    const list = await r.json();
                    for (const item of list) {
                        if (item.type === 'dir') await walk(item.path);
                        else if (item.type === 'file') files.push(item.path);
                    }
                };

                await walk(path);
                // normalize to relative to basePath when possible
                return files.map(p => p.startsWith(this.ghConfig.basePath + '/') ? p : p);
            }

            async uploadFileToGitHub() {
                if (!this.adminLogged) {
                    this.showMessage('‚ùå Vui l√≤ng ƒëƒÉng nh·∫≠p Admin!');
                    return;
                }

                const file = this.fileInput.files[0];
                const author = this.authorName.value.trim();
                const title = this.bookTitleInput.value.trim();

                if (!file || !author || !title) {
                    this.showMessage('‚ùå Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!');
                    return;
                }

                try {
                    this.showLoading();
                    
                    // Create folder name from author (C naming convention)
                    const folderName = author.replace(/[^a-zA-Z0-9]/g, '_');
                    const fileName = title.replace(/[^a-zA-Z0-9]/g, '_') + '.html';
                    const filePath = `${this.ghConfig.basePath}/${folderName}/${fileName}`;

                    // Use the pre-processed result if available to avoid duplicating work
                    let book, processedContent;
                    if (this.pendingUpload && this.pendingUpload.file === file) {
                        book = this.pendingUpload.book;
                        processedContent = this.pendingUpload.processedContent;
                    } else {
                        const r = await this.handleFileSelect(file, { fileContentDiv: this.fileContentDiv, bookTitleEl: this.bookTitle, contentReaderEl: this.contentReader });
                        book = r.book;
                        processedContent = r.processedContent;
                    }

                    // Keep processed book in memory so UI reflects it
                    this.currentBook = book;

                    // Ensure processedContent has UTF-8 meta
                    const contentWithMeta = processedContent.includes('<meta charset=') ? processedContent : processedContent.replace('<head>', '<head>\n    <meta charset="UTF-8">');

                    // Upload the processed (cleaned) content to GitHub
                    const result = await this.uploadToGitHub(filePath, contentWithMeta);
                    
                    // Update documents.json
                    await this.updateDocumentsJson({
                        title: title,
                        author: author,
                        file: `${folderName}/${fileName}`,
                        date: new Date().toISOString().split('T')[0],
                        isNew: true
                    });

                    this.hideLoading();
                    this.showMessage(`‚úÖ Upload th√†nh c√¥ng!\nüìÅ Link: ${result.html_url}`);
                    
                    // Reset form
                    this.fileInput.value = '';
                    this.authorName.value = '';
                    this.bookTitleInput.value = '';
                    this.pendingUpload = null;
                    this.clearUploadPreview();

                } catch (error) {
                    this.hideLoading();
                    if (this.uploadBtn) this.uploadBtn.disabled = false;
                    console.error('Upload error:', error);
                    this.showMessage('‚ùå L·ªói upload: ' + (error.message || error));
                }
            }

            async uploadToGitHub(path, content, message = 'Add new document') {
                const apiUrl = `https://api.github.com/repos/${this.ghConfig.owner}/${this.ghConfig.repo}/contents/${path}`;
                
                // Check if file exists
                let sha = null;
                try {
                    const checkResponse = await fetch(apiUrl, {
                        headers: {
                            'Authorization': `token ${this.ghConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (checkResponse.ok) {
                        const existingFile = await checkResponse.json();
                        sha = existingFile.sha;
                        message = 'Update existing document';
                    }
                } catch (error) {
                    // File doesn't exist, continue with upload
                }

                const payload = {
                    message: message,
                    content: btoa(unescape(encodeURIComponent(content))),
                    branch: 'main'
                };

                if (sha) {
                    payload.sha = sha;
                }

                // Attempt PUT with retries to handle concurrent updates. We'll retry up to 3 times.
                let attempts = 0;
                const maxAttempts = 3;
                let lastErr = null;

                while (attempts < maxAttempts) {
                    attempts++;
                    const response = await fetch(apiUrl, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${this.ghConfig.token}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github.v3+json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) return await response.json();

                    // handle conflict by refetching metadata (get newest sha) and retry
                    if (response.status === 409) {
                        lastErr = await response.json().catch(() => ({ message: `HTTP ${response.status}` }));
                        console.warn('‚ö†Ô∏è UPLOAD 409 conflict, attempt', attempts, 'of', maxAttempts, lastErr.message || lastErr);
                        try {
                            const meta = await fetch(apiUrl, { headers: { 'Authorization': `token ${this.ghConfig.token}`, 'Accept': 'application/vnd.github.v3+json' } });
                            if (!meta.ok) continue;
                            const existing = await meta.json();
                            // If we get content, update payload.sha and also try to merge JSON if both are JSON
                            payload.sha = existing.sha;
                            // Try merging if content looks like JSON and new content is JSON
                            try {
                                const remoteContent = existing.content ? decodeURIComponent(escape(window.atob(existing.content))) : null;
                                const ourObj = JSON.parse(content);
                                const remoteObj = remoteContent ? JSON.parse(remoteContent) : null;
                                if (remoteObj && typeof remoteObj === 'object' && typeof ourObj === 'object') {
                                    // Simple merge: remote fields preserved, new fields overwrite
                                    const merged = Object.assign({}, remoteObj, ourObj);
                                    payload.content = btoa(unescape(encodeURIComponent(JSON.stringify(merged, null, 2))));
                                }
                            } catch (e) {
                                // not JSON or merge failed ‚Äî keep our payload.content
                            }
                            // next loop iteration will retry
                            continue;
                        } catch (e) {
                            lastErr = e;
                            console.warn('Retry after 409 failed to fetch meta:', e.message || e);
                            continue;
                        }
                    }

                    // Non-409 errors -> show error
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP ${response.status}`);
                }

                // If we exit loop without success
                throw new Error(lastErr && lastErr.message ? lastErr.message : 'Failed to upload after multiple attempts');

                return await response.json();
            }

            async updateDocumentsJson(newDoc) {
                const docsPath = `${this.ghConfig.basePath}/documents.json`;
                
                // Load existing documents
                let documents = [];
                try {
                    const docsUrl = `https://raw.githubusercontent.com/${this.ghConfig.owner}/${this.ghConfig.repo}/main/${docsPath}`;
                    const response = await fetch(docsUrl);
                    if (response.ok) {
                        documents = await response.json();
                    }
                } catch (error) {
                    // documents.json doesn't exist yet
                }

                // Add new document
                const existingIndex = documents.findIndex(doc => doc.file === newDoc.file);
                if (existingIndex !== -1) {
                    documents[existingIndex] = newDoc;
                } else {
                    documents.push(newDoc);
                }

                // Upload updated documents.json
                const content = JSON.stringify(documents, null, 2);
                await this.uploadToGitHub(docsPath, content, 'Update documents list');
                
                // Update local documents
                this.documents = documents;
                localStorage.setItem('bookreader_documents', JSON.stringify(documents));
                this.renderDocumentsList();
            }

            // Read a file and attempt to detect its encoding, returning decoded text
            async readFileAsText(file, preferredEncoding = null) {
                if (!file) throw new Error('No file provided');
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onerror = (e) => reject(e);
                    reader.onload = async (e) => {
                        try {
                            const buffer = e.target.result;
                            // If caller provided a preferredEncoding use it first
                            if (preferredEncoding) {
                                try {
                                    const decoder = new TextDecoder(preferredEncoding);
                                    const text = decoder.decode(buffer);
                                    return resolve(text);
                                } catch (err) {
                                    // fall through to detection
                                }
                            }

                            // Try to detect encoding from buffer
                            try {
                                const det = await this.detectEncoding(buffer);
                                return resolve(det.text);
                            } catch (err) {
                                // fallback to UTF-8
                                const text = new TextDecoder('utf-8').decode(buffer);
                                return resolve(text);
                            }
                        } catch (err) {
                            reject(err);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            // Process a selected file and return a normalized "book" object plus processed content
            // options: { fileContentDiv, bookTitleEl, contentReaderEl, storageKey, lastBookKey, encoding }
            async handleFileSelect(file, options = {}) {
                const {
                    fileContentDiv = this.fileContentDiv,
                    bookTitleEl = this.bookTitle,
                    contentReaderEl = this.contentReader,
                    storageKey = 'bookreader_books',
                    lastBookKey = 'bookreader_lastbook',
                    encoding = null
                } = options;

                if (!file) throw new Error('No file provided');

                const raw = await this.readFileAsText(file, encoding);
                const fileName = file.name.replace(/\.[^/.]+$/, '');

                // Fix encoding mojibake and ensure meta
                let processed = this.fixContentEncoding(raw);

                // Ensure meta charset header
                if (!processed.includes('<meta charset=')) {
                    processed = processed.replace('<head>', '<head>\n    <meta charset="UTF-8">');
                }

                // If a DOM element is available, render and optimize it for TOC/pages detection
                let headings = [];
                if (fileContentDiv) {
                    // Render into a temporary container inside the provided div so we don't overwrite main UI
                    let temp = fileContentDiv.querySelector('.upload-temp');
                    if (!temp) {
                        temp = document.createElement('div');
                        temp.className = 'upload-temp';
                        temp.style.display = 'none';
                        fileContentDiv.appendChild(temp);
                    }

                    temp.innerHTML = processed;
                    // Run optimizations that modify DOM (images, tables...)
                    try { this.optimizeContent(); } catch(e) { console.warn('optimizeContent failed', e); }
                    // Generate TOC using existing method; it expects content already in fileContentDiv
                    headings = this.generateTOC(fileContentDiv, { tocListEl: null });
                }

                // Calculate pages if reader element exists
                let totalPages = null;
                if (contentReaderEl && fileContentDiv) {
                    try {
                        totalPages = this.calculatePages(contentReaderEl, fileContentDiv, { totalPagesEl: null });
                    } catch (e) {
                        console.warn('calculatePages failed', e);
                    }
                }

                const book = {
                    name: fileName,
                    content: processed,
                    timestamp: Date.now(),
                    lastPosition: 0
                };

                // Save local (processed) copy before trying to upload
                try {
                    await this.saveBookToStorage(book);
                    if (lastBookKey) localStorage.setItem(lastBookKey, fileName);
                } catch (e) {
                    console.warn('Save book to storage (upload flow) failed', e);
                }

                // Return normalized book and processed content to caller
                return { book, processedContent: processed, headings, totalPages };
            }

            renderDocumentsList() {
                if (this.documents.length === 0) {
                    this.documentsList.innerHTML = '<div class="document-placeholder">Ch∆∞a c√≥ t√†i li·ªáu n√†o</div>';
                    return;
                }
                
                this.documentsList.innerHTML = this.documents.map((doc, index) => `
                    <div class="document-item" data-index="${index}">
                        <div class="document-icon">üìÑ</div>
                        <div class="document-info">
                            <div class="document-title">${this.escapeHtml(doc.title)}</div>
                            <div class="document-meta">
                                <span>${this.escapeHtml(doc.author)}</span>
                                <span>‚Ä¢</span>
                                <span>${doc.date || 'N/A'}</span>
                                ${doc.isNew ? '<span class="badge-new">M·ªöI</span>' : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // Add click events
                this.documentsList.querySelectorAll('.document-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const index = parseInt(item.getAttribute('data-index'));
                        this.openDocument(index);
                    });
                });
            }

           
            displayContentInIframe(content) {
                // Create iframe for better isolation and font rendering
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = 'var(--bg-primary)';
                
                // Ensure UTF-8 meta tag
                if (!content.includes('<meta charset=')) {
                    content = content.replace('<head>', '<head>\n    <meta charset="UTF-8">');
                }
                
                // Add basic styles for iframe content
                const styles = `
                    <style>
                        body { 
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            line-height: 1.6; 
                            margin: 0; 
                            padding: 16px;
                            background: var(--bg-primary);
                            color: var(--text-primary);
                        }
                        img { max-width: 100%; height: auto; }
                        table { width: 100%; border-collapse: collapse; }
                        th, td { border: 1px solid var(--border-color); padding: 8px; }
                    </style>
                `;
                
                content = content.replace('</head>', styles + '</head>');
                
                this.fileContentDiv.innerHTML = '';
                this.fileContentDiv.appendChild(iframe);
                
                iframe.onload = () => {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(content);
                    iframeDoc.close();
                    
                    // Apply theme to iframe
                    this.applyThemeToIframe(iframe);
                };
            }

            applyThemeToIframe(iframe) {
                const theme = localStorage.getItem('bookreader-theme') || 'light';
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                iframeDoc.body.setAttribute('data-theme', theme);
                iframeDoc.documentElement.style.cssText = `
                    --bg-primary: ${getComputedStyle(document.documentElement).getPropertyValue('--bg-primary')};
                    --text-primary: ${getComputedStyle(document.documentElement).getPropertyValue('--text-primary')};
                    --border-color: ${getComputedStyle(document.documentElement).getPropertyValue('--border-color')};
                `;
            }

           
            displayTOCWithSearch() {
                if (this.headings.length === 0) {
                    this.tocList.innerHTML = '<li class="toc-placeholder">Kh√¥ng t√¨m th·∫•y m·ª•c l·ª•c trong file</li>';
                    return;
                }

                const tocItemsHTML = this.headings.map((heading, index) => {
                    return `
                        <li class="toc-item">
                            <a href="#${heading.id}" class="toc-link level-${heading.level}" data-index="${index}">
                                <span class="toc-text">${heading.text}</span>
                            </a>
                        </li>
                    `;
                }).join('');

                this.tocList.innerHTML = tocItemsHTML;

                // Add search functionality
                this.tocSearch.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase().trim();
                    
                    if (searchTerm === '') {
                        this.tocSearchResults.style.display = 'none';
                        this.showAllTOCItems();
                        return;
                    }

                    const filteredHeadings = this.headings.filter(heading => 
                        heading.text.toLowerCase().includes(searchTerm)
                    );

                    this.filterTOCItems(searchTerm);
                    this.showSearchResults(filteredHeadings, searchTerm);
                });

                // Add click events for TOC links
                this.tocList.querySelectorAll('.toc-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const index = parseInt(link.getAttribute('data-index'));
                        this.scrollToHeading(this.headings[index].element);
                        this.closeMenu();
                    });
                });
            }

            filterTOCItems(searchTerm) {
                const tocItems = this.tocList.querySelectorAll('.toc-item');
                
                tocItems.forEach(item => {
                    const text = item.querySelector('.toc-text').textContent.toLowerCase();
                    if (text.includes(searchTerm)) {
                        item.style.display = 'flex';
                        const originalText = item.querySelector('.toc-text').textContent;
                        const highlightedText = this.highlightText(originalText, searchTerm);
                        item.querySelector('.toc-text').innerHTML = highlightedText;
                    } else {
                        item.style.display = 'none';
                    }
                });
            }

            showAllTOCItems() {
                const tocItems = this.tocList.querySelectorAll('.toc-item');
                tocItems.forEach(item => {
                    item.style.display = 'flex';
                    const text = item.querySelector('.toc-text').textContent;
                    item.querySelector('.toc-text').textContent = text;
                });
            }

            showSearchResults(filteredHeadings, searchTerm) {
                if (filteredHeadings.length === 0) {
                    this.tocSearchResults.innerHTML = '<div class="toc-no-results">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£</div>';
                    this.tocSearchResults.style.display = 'block';
                    return;
                }

                const resultsHTML = filteredHeadings.map(heading => {
                    const highlightedText = this.highlightText(heading.text, searchTerm);
                    return `
                        <div class="toc-search-result" data-index="${this.headings.indexOf(heading)}">
                            <div class="toc-search-text">${highlightedText}</div>
                        </div>
                    `;
                }).join('');

                this.tocSearchResults.innerHTML = resultsHTML;
                this.tocSearchResults.style.display = 'block';

                this.tocSearchResults.querySelectorAll('.toc-search-result').forEach(result => {
                    result.addEventListener('click', () => {
                        const index = parseInt(result.getAttribute('data-index'));
                        this.scrollToHeading(this.headings[index].element);
                        this.closeMenu();
                        this.tocSearchResults.style.display = 'none';
                        this.tocSearch.value = '';
                        this.showAllTOCItems();
                    });
                });
            }

            highlightText(text, searchTerm) {
                if (!searchTerm) return text;
                const regex = new RegExp(`(${this.escapeRegex(searchTerm)})`, 'gi');
                return text.replace(regex, '<mark class="search-highlight">$1</mark>');
            }

            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

       
            /* =========================
               CORE FUNCTIONALITY (ORIGINAL LOGIC)
               ========================= */
            disableZoom() {
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                document.addEventListener('gesturechange', (e) => e.preventDefault());
                document.addEventListener('gestureend', (e) => e.preventDefault());
                
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }

            disableHorizontalScroll() {
                this.contentReader.addEventListener('scroll', (e) => {
                    if (e.target.scrollLeft !== 0) {
                        e.target.scrollLeft = 0;
                    }
                });
            }

            loadPreferences() {
                const savedTheme = localStorage.getItem('bookreader-theme');
                if (savedTheme) {
                    this.themeSelect.value = savedTheme;
                    document.body.setAttribute('data-theme', savedTheme);
                }
                
                const savedFontSize = localStorage.getItem('bookreader-fontsize');
                if (savedFontSize) {
                    this.fontSizeSelect.value = savedFontSize;
                }
            }

            loadLastBook() {
                const lastBookName = localStorage.getItem('bookreader_lastbook');
                if (lastBookName && this.documents.length > 0) {
                    const docIndex = this.documents.findIndex(doc => doc.title === lastBookName);
                    if (docIndex !== -1) {
                        this.openDocument(docIndex);
                    }
                }
            }

            toggleMenu() {
                this.isMenuOpen = !this.isMenuOpen;
                this.sidebar.classList.toggle('active', this.isMenuOpen);
                if (this.isMenuOpen) {
                    this.closeSettings();
                }
            }

            closeMenu() {
                this.isMenuOpen = false;
                this.sidebar.classList.remove('active');
            }

            toggleSettings() {
                this.isSettingsOpen = !this.isSettingsOpen;
                this.settingsPanel.classList.toggle('active', this.isSettingsOpen);
                if (this.isSettingsOpen) {
                    this.closeMenu();
                }
            }

            closeSettings() {
                this.isSettingsOpen = false;
                this.settingsPanel.classList.remove('active');
            }

            // Save a book object to localStorage. If no bookArg provided, use this.currentBook
            saveBookToStorage(bookArg) {
                const bookToSave = bookArg || this.currentBook;
                if (!bookToSave) return;
                
                try {
                    const savedBooks = this.getSavedBooks();
                    const existingBookIndex = savedBooks.findIndex(book => book.name === bookToSave.name);

                    if (existingBookIndex !== -1) {
                        savedBooks[existingBookIndex] = bookToSave;
                    } else {
                        savedBooks.push(bookToSave);
                    }
                    
                    try {
                        localStorage.setItem('bookreader_books', JSON.stringify(savedBooks));
                        console.log('üíæ Book saved to localStorage');
                    } catch (err) {
                        // Handle localStorage quota exceeded: try to shrink existing stored books
                        console.warn('‚ö†Ô∏è Saving books failed, attempting fallback:', err.message || err);
                        if (err && (err.name === 'QuotaExceededError' || /quota/i.test(err.message || ''))) {
                            try {
                                // Remove content of other saved books to free space
                                const existing = this.getSavedBooks();
                                const compact = existing.map(b => b.name === bookToSave.name ? ({ ...bookToSave, content: '' }) : ({ ...b, content: '' }));
                                localStorage.setItem('bookreader_books', JSON.stringify(compact));
                                console.log('üíæ Book saved in compact mode (no content) due to quota');
                            } catch (err2) {
                                try {
                                    // Last resort: store only minimal metadata for current book
                                    const metaOnly = [{ name: bookToSave.name, timestamp: bookToSave.timestamp, lastPosition: bookToSave.lastPosition }];
                                    localStorage.setItem('bookreader_books', JSON.stringify(metaOnly));
                                    console.log('üíæ Book saved as metadata-only due to quota');
                                } catch (err3) {
                                    console.error('‚ùå Unable to save books to localStorage after fallbacks:', err3.message || err3);
                                    this.showMessage('‚ùå Kh√¥ng th·ªÉ l∆∞u s√°ch c·ª•c b·ªô: b·ªô nh·ªõ tr√¨nh duy·ªát ƒë·∫ßy.');
                                }
                            }
                        } else {
                            console.error('‚ùå Error saving book to storage:', err.message || err);
                        }
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error saving book to storage:', error);
                }
            }

            getSavedBooks() {
                try {
                    const savedBooks = localStorage.getItem('bookreader_books');
                    return savedBooks ? JSON.parse(savedBooks) : [];
                } catch (error) {
                    console.error('‚ùå Error reading saved books:', error);
                    return [];
                }
            }

            saveReadingProgress() {
                if (!this.currentBook) return;
                
                const scrollTop = this.contentReader.scrollTop;
                this.currentBook.lastPosition = scrollTop;
                this.currentBook.lastRead = new Date().getTime();
                
                this.saveBookToStorage();
            }

            restoreReadingProgress() {
                if (!this.currentBook) return;
                
                const savedBooks = this.getSavedBooks();
                const savedBook = savedBooks.find(book => book.name === this.currentBook.name);
                
                if (savedBook && savedBook.lastPosition) {
                    setTimeout(() => {
                        this.contentReader.scrollTo({
                            top: savedBook.lastPosition,
                            behavior: 'smooth'
                        });
                        
                        setTimeout(() => {
                            this.updateCurrentPage();
                        }, 200);
                        
                        console.log('üìñ Reading progress restored');
                    }, 100);
                }
            }


    displayContentDirectly(content) {
        // X√≥a iframe c≈© n·∫øu c√≥
        this.fileContentDiv.innerHTML = '';
        
        // T·∫°o div ƒë·ªÉ hi·ªÉn th·ªã n·ªôi dung tr·ª±c ti·∫øp
        const contentDiv = document.createElement('div');
        contentDiv.className = 'file-content-display';
        contentDiv.innerHTML = content;
        
        // Th√™m v√†o DOM
        this.fileContentDiv.appendChild(contentDiv);
        
        // T·ªëi ∆∞u h√≥a n·ªôi dung
        this.optimizeContent();
        
        console.log('üìÑ Content displayed directly');
    }

    optimizeContent() {
        const contentDiv = this.fileContentDiv.querySelector('.file-content-display');
        if (!contentDiv) return;
        
        // T·ªëi ∆∞u h√≥a images
        contentDiv.querySelectorAll('img').forEach(img => {
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.loading = 'lazy';
        });
        
        // T·ªëi ∆∞u h√≥a tables
        contentDiv.querySelectorAll('table').forEach(table => {
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.display = 'block';
            table.style.overflowX = 'auto';
            table.style.fontSize = '0.9em';
        });
        
        // ƒê·∫£m b·∫£o t·∫•t c·∫£ elements kh√¥ng v∆∞·ª£t qu√° width
        contentDiv.querySelectorAll('*').forEach(el => {
            el.style.maxWidth = '100%';
            el.style.boxSizing = 'border-box';
        });
        
        // X√≥a empty elements
        contentDiv.querySelectorAll('p, div').forEach(el => {
            if (!el.textContent.trim() && !el.querySelector('img, table')) {
                el.remove();
            }
        });
        
        console.log('üé® Content optimized');
    }
 fixContentEncoding(content) {
        // Th√™m meta charset UTF-8 n·∫øu thi·∫øu
        if (!content.includes('<meta charset=') && !content.includes('charset=')) {
            content = content.replace('<head>', '<head>\n    <meta charset="UTF-8">');
            console.log('üîß Added UTF-8 meta tag');
        }
        
        // S·ª≠a c√°c k√Ω t·ª± ti·∫øng Vi·ªát b·ªã l·ªói ph·ªï bi·∫øn
        const encodingFixes = {
            // Windows-1252 to UTF-8 fixes
            '√É¬°': '√°', '√É ': '√†', '√É¬£': '√£', '√É¬¢': '√¢', '√É¬©': '√©',
            '√É¬®': '√®', '√É¬™': '√™', '√É¬≠': '√≠', '√É¬¨': '√¨', '√É¬≥': '√≥',
            '√É¬≤': '√≤', '√É¬¥': '√¥', '√É¬∫': '√∫', '√É¬π': '√π', '√É¬Ω': '√Ω',
            '√É¬Å': '√Å', '√É‚Ç¨': '√Ä', '√É∆í': '√É', '√É‚Äö': '√Ç', '√É‚Ä∞': '√â',
            '√ÉÀÜ': '√à', '√É≈†': '√ä', '√É¬ç': '√ç', '√É≈í': '√å', '√É‚Äú': '√ì',
            '√É‚Äô': '√í', '√É‚Äù': '√î', '√É≈°': '√ö', '√É‚Ñ¢': '√ô', '√É¬ù': '√ù',
            '√Ñ∆í': 'ƒÉ', '√Ñ‚Äö': 'ƒÇ', '√Ü¬°': '∆°', '√Ü¬Ø': '∆∞', '√¢‚Ç¨‚Äú': '‚Äì',
            '√¢‚Ç¨≈ì': '‚Äú', '√¢‚Ç¨': '‚Äù', '√¢‚Ç¨¬¶': '‚Ä¶',
            
            // UTF-8 mojibake fixes
            '√°¬∫¬°': '·∫°', '√°¬∫¬£': '·∫£', '√°¬∫¬•': '·∫•', '√°¬∫¬ß': '·∫ß', '√°¬∫¬≠': '·∫≠',
            '√°¬∫¬©': '·∫©', '√°¬∫¬´': '·∫´', '√°¬∫¬Ø': '·∫Ø', '√°¬∫¬±': '·∫±', '√°¬∫¬∑': '·∫∑',
            '√°¬∫¬≥': '·∫≥', '√°¬∫¬µ': '·∫µ', '√°¬∫¬π': '·∫π', '√°¬∫¬ª': '·∫ª', '√°¬∫¬Ω': '·∫Ω',
            '√°¬∫¬ø': '·∫ø', '√°¬ª¬Å': '·ªÅ', '√°¬ª‚Ä°': '·ªá', '√°¬ª∆í': '·ªÉ', '√°¬ª‚Ä¶': '·ªÖ',
            '√°¬ª‚Äπ': '·ªã', '√°¬ª‚Ä∞': '·ªâ', '√°¬ª¬ç': '·ªç', '√°¬ª¬è': '·ªè', '√°¬ª‚Äò': '·ªë',
            '√°¬ª‚Äú': '·ªì', '√°¬ª‚Ñ¢': '·ªô', '√°¬ª‚Ä¢': '·ªï', '√°¬ª‚Äî': '·ªó', '√°¬ª‚Ä∫': '·ªõ',
            '√°¬ª¬ù': '·ªù', '√°¬ª¬£': '·ª£', '√°¬ª≈∏': '·ªü', '√°¬ª¬°': '·ª°', '√°¬ª¬•': '·ª•',
            '√°¬ª¬ß': '·ªß', '√Ö¬©': '≈©', '√°¬ª¬©': '·ª©', '√°¬ª¬´': '·ª´', '√°¬ª¬±': '·ª±',
            '√°¬ª¬≠': '·ª≠', '√°¬ª¬Ø': '·ªØ', '√°¬ª¬≥': '·ª≥', '√°¬ª¬∑': '·ªµ', '√°¬ª¬π': '·ªπ'
        };

        // √Åp d·ª•ng t·∫•t c·∫£ c√°c fix
        Object.keys(encodingFixes).forEach(badChar => {
            const regex = new RegExp(badChar, 'g');
            content = content.replace(regex, encodingFixes[badChar]);
        });

        console.log('üîß Applied encoding fixes');
        return content;
    }

    displayContentDirectly(content) {
        // X√≥a n·ªôi dung c≈©
        this.fileContentDiv.innerHTML = '';
        
        // T·∫°o div ƒë·ªÉ hi·ªÉn th·ªã n·ªôi dung
        const contentDiv = document.createElement('div');
        contentDiv.className = 'file-content-display';
        
        // Th√™m CSS ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã ƒë√∫ng
        const style = document.createElement('style');
        style.textContent = `
            .file-content-display {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                line-height: 1.6;
                color: var(--text-primary);
                max-width: 100%;
                overflow-wrap: break-word;
            }
            .file-content-display * {
                max-width: 100%;
                box-sizing: border-box;
            }
            .file-content-display img {
                max-width: 100%;
                height: auto;
            }
            .file-content-display table {
                width: 100%;
                border-collapse: collapse;
            }
            .file-content-display th, 
            .file-content-display td {
                border: 1px solid var(--border-color);
                padding: 8px;
            }
            .file-content-display h1, 
            .file-content-display h2, 
            .file-content-display h3 {
                margin: 1.2em 0 0.6em 0;
                color: var(--text-primary);
            }
            .file-content-display p {
                margin-bottom: 1em;
                text-align: justify;
            }
        `;
        
        // Th√™m style v√† content
        this.fileContentDiv.appendChild(style);
        contentDiv.innerHTML = content;
        this.fileContentDiv.appendChild(contentDiv);
        
        // T·ªëi ∆∞u h√≥a n·ªôi dung
        this.optimizeContent();
        
        console.log('üìÑ Content displayed with proper encoding');
    }

    optimizeContent() {
        const contentDiv = this.fileContentDiv.querySelector('.file-content-display');
        if (!contentDiv) return;
        
        // T·ªëi ∆∞u h√≥a images
        contentDiv.querySelectorAll('img').forEach(img => {
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.loading = 'lazy';
        });
        
        // T·ªëi ∆∞u h√≥a tables
        contentDiv.querySelectorAll('table').forEach(table => {
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.display = 'block';
            table.style.overflowX = 'auto';
        });
        
        // ƒê·∫£m b·∫£o responsive
        contentDiv.querySelectorAll('*').forEach(el => {
            el.style.maxWidth = '100%';
        });
        
        console.log('üé® Content optimized');
    }

    // TH·ª¨ PH∆Ø∆†NG PH√ÅP KH√ÅC: D√πng TextDecoder v·ªõi detection encoding
    async detectEncoding(buffer) {
        const encodings = ['utf-8', 'windows-1252', 'iso-8859-1', 'utf-16'];
        
        for (let encoding of encodings) {
            try {
                const decoder = new TextDecoder(encoding);
                const text = decoder.decode(buffer);
                
                // Ki·ªÉm tra xem text c√≥ h·ª£p l·ªá kh√¥ng (c√≥ ch·ª©a k√Ω t·ª± ti·∫øng Vi·ªát)
                const vietnameseChars = /[√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµƒë]/i;
                if (vietnameseChars.test(text)) {
                    console.log(`‚úÖ Detected encoding: ${encoding}`);
                    return { encoding, text };
                }
            } catch (e) {
                continue;
            }
        }
        
        // Fallback to UTF-8
        console.log('‚ö†Ô∏è Using UTF-8 as fallback');
        return { encoding: 'utf-8', text: new TextDecoder('utf-8').decode(buffer) };
    }

    async openDocument(index) {
        console.log('üéØ Opening document:', index);
        
        const doc = this.documents[index];
        if (!doc) {
            this.showMessage('‚ùå T√†i li·ªáu kh√¥ng t·ªìn t·∫°i');
            return false;
        }
        
        this.showLoading();
        this.placeholderDiv.style.display = 'none';
        
        try {
            let content = '';
            
            if (doc.file) {
                const filePath = `${this.ghConfig.basePath}/${doc.file}`;
                const fileUrl = `https://raw.githubusercontent.com/${this.ghConfig.owner}/${this.ghConfig.repo}/main/${filePath}`;
                
                console.log('üìñ Loading from:', fileUrl);
                
                const response = await fetch(fileUrl);
                if (!response.ok) {
                    // missing file: do not throw hard; return false to allow callers to try next
                    if (response.status === 404) {
                        console.warn('‚ö†Ô∏è File not found:', fileUrl);
                        this.hideLoading();
                        // don't popup for every missing file ‚Äî return false and let caller continue
                        return false;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const buffer = await response.arrayBuffer();
                
                // D√πng encoding detection
                const result = await this.detectEncoding(buffer);
                content = result.text;
                console.log(`üìù Used encoding: ${result.encoding}`);
                
            } else if (doc.content) {
                content = doc.content;
            } else {
                throw new Error('T√†i li·ªáu kh√¥ng c√≥ n·ªôi dung');
            }
            
            // √Åp d·ª•ng encoding fixes
            content = this.fixContentEncoding(content);
            
            // Log access
            try {
                await this.logAccess('document_open', doc.title);
            } catch (e) {
                console.log('‚ö†Ô∏è Log access failed:', e.message);
            }
            
            // Hi·ªÉn th·ªã n·ªôi dung
            this.displayContentDirectly(content);
            
            this.fileContentDiv.style.display = 'block';
            this.bookTitle.textContent = doc.title;
            
            this.generateTOC();
            this.calculatePages();
            
            // Save to storage
            this.currentBook = {
                name: doc.title,
                content: content,
                timestamp: new Date().getTime(),
                lastPosition: 0
            };
            
            this.saveBookToStorage();
            localStorage.setItem('bookreader_lastbook', doc.title);
            this.restoreReadingProgress();
            
            // Apply settings
            const savedFontSize = localStorage.getItem('bookreader-fontsize');
            if (savedFontSize) {
                this.changeFontSize(savedFontSize);
            }
            
            this.hideLoading();
            this.closeMenu();
            
            console.log('‚úÖ Document loaded successfully');
            
        } catch (error) {
            console.error('‚ùå Error loading document:', error);
            this.hideLoading();
            // If it was a not-found (we already returned), for other errors show message
            if (error && error.message && error.message.includes('HTTP 404')) return false;
            this.showError('L·ªói khi t·∫£i t√†i li·ªáu: ' + (error.message || error));
            return false;
        }
        return false;
    }
    
    generateTOC() {
        this.tocList.innerHTML = '';
        this.headings = [];
        
        const contentDiv = this.fileContentDiv.querySelector('.file-content-display');
        if (!contentDiv) {
            console.log('‚ùå No content div found for TOC');
            return;
        }
        
        const headings = contentDiv.querySelectorAll('h1, h2, h3');
        console.log('üìë Found headings:', headings.length);
        
        headings.forEach((heading, index) => {
            const id = `toc-heading-${index}`;
            heading.id = id;
            
            const level = parseInt(heading.tagName.substring(1));
            
            this.headings.push({
                id: id,
                text: heading.textContent.trim(),
                element: heading,
                level: level
            });
        });
        
        this.displayTOCWithSearch();
    }

    scrollToHeading(element) {
        element.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
        });
        
        setTimeout(() => this.updateCurrentPage(), 300);
    }

    changeFontSize(size) {
        const contentDiv = this.fileContentDiv.querySelector('.file-content-display');
        if (contentDiv) {
            contentDiv.style.fontSize = `${size}rem`;
        }
        localStorage.setItem('bookreader-fontsize', size);
        setTimeout(() => this.calculatePages(), 100);
    }

    calculatePages() {
        const contentHeight = this.contentReader.clientHeight;
        const totalHeight = this.fileContentDiv.scrollHeight;
        this.totalPages = Math.ceil(totalHeight / contentHeight);
        this.totalPagesEl.textContent = this.totalPages;
        this.updateCurrentPage();
        
        console.log('üìÑ Pages calculated:', this.totalPages);
    }

   



            updateCurrentPage() {
                const scrollTop = this.contentReader.scrollTop;
                const contentHeight = this.contentReader.clientHeight;
                const totalHeight = this.fileContentDiv.scrollHeight;
                
                if (totalHeight > 0) {
                    this.currentPage = Math.floor((scrollTop / totalHeight) * this.totalPages);
                    this.currentPageEl.textContent = this.currentPage + 1;
                    
                    const progress = ((this.currentPage + 1) / this.totalPages) * 100;
                    this.progressFill.style.width = `${progress}%`;
                }
            }

            handleTouchStart(e) {
                this.touchStartX = e.touches[0].clientX;
                this.touchStartY = e.touches[0].clientY;
            }

            handleTouchEnd(e) {
                if (!this.touchStartX) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const diffX = touchEndX - this.touchStartX;
                const diffY = touchEndY - this.touchStartY;
                
                // Only handle horizontal swipe with small vertical deviation
                if (Math.abs(diffX) > 50 && Math.abs(diffY) < 100) {
                    if (diffX > 0) {
                        // Swipe right - previous page
                        this.previousPage();
                    } else {
                        // Swipe left - next page
                        this.nextPage();
                    }
                }
                
                this.touchStartX = 0;
                this.touchStartY = 0;
            }

            nextPage() {
                if (this.currentPage < this.totalPages - 1) {
                    this.goToPage(this.currentPage + 1);
                }
            }

            previousPage() {
                if (this.currentPage > 0) {
                    this.goToPage(this.currentPage - 1);
                }
            }

            goToPage(page) {
                if (page < 0 || page >= this.totalPages) return;
                
                this.currentPage = page;
                const scrollPosition = (page / this.totalPages) * this.fileContentDiv.scrollHeight;
                
                this.contentReader.scrollTo({
                    top: scrollPosition,
                    behavior: 'smooth'
                });
            }

            handleKeydown(e) {
                // Intercept F5 to refresh documents from GitHub without a full page reload
                if (e.key === 'F5' || e.keyCode === 116) {
                    e.preventDefault();
                    if (this.ghConfig && this.ghConfig.owner && this.ghConfig.repo) {
                        // reload from remote repository
                        this.loadFromGitHub().catch(() => {});
                    } else {
                        this.showMessage('‚ùå Ch∆∞a c·∫•u h√¨nh GitHub (owner/repo).');
                    }
                    return;
                }
                if (e.key === 'ArrowLeft') {
                    this.previousPage();
                } else if (e.key === 'ArrowRight') {
                    this.nextPage();
                } else if (e.key === 'Escape') {
                    if (this.isMenuOpen) this.closeMenu();
                    if (this.isSettingsOpen) this.closeSettings();
                }
            }

            changeTheme(theme) {
                document.body.setAttribute('data-theme', theme);
                localStorage.setItem('bookreader-theme', theme);
                
                // Apply theme to iframe if exists
                const iframe = this.fileContentDiv.querySelector('iframe');
                if (iframe) {
                    this.applyThemeToIframe(iframe);
                }
            }

            showLoading() {
                this.loadingOverlay.classList.add('active');
            }

            hideLoading() {
                this.loadingOverlay.classList.remove('active');
            }

            showError(message) {
                this.placeholderDiv.style.display = 'block';
                this.placeholderDiv.innerHTML = `
                    <div style="font-size: 48px;">‚ùå</div>
                    <h3>ƒê√£ x·∫£y ra l·ªói</h3>
                    <p>${message}</p>
                    <button class="get-started-btn" onclick="location.reload()">Th·ª≠ l·∫°i</button>
                `;
                this.hideLoading();
            }

            showMessage(message) {
                alert(message);
            }

            showUploadPreview(res) {
                const el = document.getElementById('upload-preview');
                if (!el) return;
                const book = res.book || {};
                const processed = res.processedContent || '';
                const headings = res.headings || [];
                const totalPages = res.totalPages || 'N/A';
                const sizeKB = (new Blob([processed]).size / 1024).toFixed(1);

                el.style.display = 'block';
                el.innerHTML = `
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
                        <div style="flex:1;min-width:0">
                            <div style="font-weight:600;color:var(--text-primary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${this.escapeHtml(book.name || 'Kh√¥ng t√™n')}</div>
                            <div style="font-size:0.85em;color:var(--text-secondary);margin-top:4px">K√≠ch th∆∞·ªõc: ${sizeKB} KB ¬∑ M·ª•c l·ª•c: ${headings.length} ¬∑ Trang ~ ${totalPages}</div>
                        </div>
                        <div style="display:flex;gap:6px">
                            <button id="upload-preview-view" class="upload-btn" style="padding:6px 10px">Xem</button>
                            <button id="upload-preview-clear" class="upload-btn" style="padding:6px 10px">H·ªßy</button>
                        </div>
                    </div>
                `;

                // Bind events
                const viewBtn = document.getElementById('upload-preview-view');
                const clearBtn = document.getElementById('upload-preview-clear');
                if (viewBtn) viewBtn.addEventListener('click', () => {
                    try {
                        this.currentBook = book;
                        this.displayContentDirectly(processed);
                        this.generateTOC();
                        this.calculatePages();
                        this.showMessage('üëÅÔ∏è ƒê√£ hi·ªÉn th·ªã b·∫£n x·ª≠ l√Ω (preview)');
                    } catch (e) {
                        console.warn('Preview failed', e);
                        this.showMessage('‚ùå Hi·ªÉn th·ªã preview th·∫•t b·∫°i: ' + (e.message || e));
                    }
                });

                if (clearBtn) clearBtn.addEventListener('click', () => {
                    this.pendingUpload = null;
                    this.fileInput.value = '';
                    this.bookTitleInput.value = '';
                    this.authorName.value = '';
                    this.clearUploadPreview();
                    this.showMessage('üóëÔ∏è ƒê√£ h·ªßy b·∫£n x·ª≠ l√Ω');
                });
            }

            clearUploadPreview() {
                const el = document.getElementById('upload-preview');
                if (!el) return;
                el.style.display = 'none';
                el.innerHTML = '';
                if (this.uploadBtn) this.uploadBtn.disabled = true;
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new BookReader();
        });
        
    </script>
</body>
</html>
